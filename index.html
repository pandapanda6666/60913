<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>經典超級瑪莉 - HTML 版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #5c94fc; /* 經典藍天色 */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #game-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            background-color: #5c94fc;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            border: 4px solid #000;
            max-width: 100%;
            image-rendering: pixelated;
        }

        .ui-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            font-size: 24px;
        }

        .footer {
            background: #000;
            color: white;
            text-align: center;
            padding: 10px;
            font-size: 14px;
        }

        .footer a {
            color: #ffeb3b;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }

        #start-screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10;
        }

        .btn {
            background: #e74c3c;
            color: white;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            transition: transform 0.1s;
            margin-top: 20px;
            border: none;
        }

        .btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-panel">
        <div>MARIO: <span id="score">000000</span></div>
        <div>COINS: <span id="coins">0</span></div>
    </div>

    <div id="start-screen">
        <h1 class="text-6xl mb-4 font-bold">SUPER MARIO</h1>
        <p class="text-xl">使用 方向鍵 移動與跳躍</p>
        <button class="btn" onclick="startGame()">開始遊戲</button>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<footer class="footer">
    版權所有 © 2025 <a href="https://60913panda.github.io/PPAW/" target="_blank">PandaPanda的AI日常</a> All Rights Reserved.
</footer>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const coinsEl = document.getElementById('coins');
    const startScreen = document.getElementById('start-screen');

    // 遊戲常數
    const TILE_SIZE = 40;
    const GRAVITY = 0.8;
    const FRICTION = 0.8;
    const JUMP_FORCE = -15;
    const SPEED = 5;

    // 畫布大小
    canvas.width = 800;
    canvas.height = 480;

    let gameActive = false;
    let score = 0;
    let coins = 0;
    let scrollX = 0;

    // 按鍵監聽
    const keys = {};
    window.addEventListener('keydown', e => keys[e.code] = true);
    window.addEventListener('keyup', e => keys[e.code] = false);

    class Player {
        constructor() {
            this.reset();
        }

        reset() {
            this.x = 100;
            this.y = 300;
            this.width = 32;
            this.height = 32;
            this.vx = 0;
            this.vy = 0;
            this.onGround = false;
            this.direction = 1; // 1: right, -1: left
        }

        update() {
            // 水平移動
            if (keys['ArrowRight']) {
                this.vx += 0.5;
                this.direction = 1;
            } else if (keys['ArrowLeft']) {
                this.vx -= 0.5;
                this.direction = -1;
            }

            this.vx *= FRICTION;

            // 跳躍
            if (keys['Space'] || keys['ArrowUp'] || keys['KeyW']) {
                if (this.onGround) {
                    this.vy = JUMP_FORCE;
                    this.onGround = false;
                }
            }

            // 重力
            this.vy += GRAVITY;

            // 更新位置
            this.x += this.vx;
            this.y += this.vy;

            // 邊界檢查
            if (this.x < 0) this.x = 0;
            
            // 死亡檢查
            if (this.y > canvas.height) {
                gameOver();
            }
        }

        draw() {
            ctx.fillStyle = '#ff0000'; // 帽子與衣服
            ctx.fillRect(this.x - scrollX, this.y, this.width, this.height);
            
            // 畫個簡單的臉部特徵
            ctx.fillStyle = '#ffdbac'; // 皮膚
            ctx.fillRect(this.x - scrollX + (this.direction === 1 ? 16 : 0), this.y + 4, 16, 12);
            
            ctx.fillStyle = '#0000ff'; // 吊帶褲
            ctx.fillRect(this.x - scrollX, this.y + 16, this.width, 16);
        }
    }

    class Enemy {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 32;
            this.height = 32;
            this.vx = -2;
            this.alive = true;
        }

        update() {
            if (!this.alive) return;
            this.x += this.vx;
            
            // 簡單的障礙轉向
            const tileX = Math.floor((this.x + (this.vx > 0 ? this.width : 0)) / TILE_SIZE);
            const tileY = Math.floor((this.y + this.height / 2) / TILE_SIZE);
            if (levelData[tileY] && levelData[tileY][tileX] === 1) {
                this.vx *= -1;
            }
        }

        draw() {
            if (!this.alive) return;
            ctx.fillStyle = '#8B4513'; // 咖啡色 (栗子頭)
            ctx.beginPath();
            ctx.arc(this.x - scrollX + 16, this.y + 16, 16, 0, Math.PI * 2);
            ctx.fill();
            // 眼睛
            ctx.fillStyle = 'white';
            ctx.fillRect(this.x - scrollX + 8, this.y + 8, 4, 4);
            ctx.fillRect(this.x - scrollX + 20, this.y + 8, 4, 4);
        }
    }

    // 地圖數據 (0: 空, 1: 地板/磚塊, 2: 金幣, 3: 問號箱)
    const levelMap = [
        "                                                                                ",
        "                                                                                ",
        "                                                                                ",
        "                                                                                ",
        "               222                                                              ",
        "                                                                                ",
        "          3  13131                                                              ",
        "                                     222                                        ",
        "                                    11111                                       ",
        "                    1111                                                        ",
        "                                                                                ",
        "11111111111111111111111111111111111111111111111111111111111111111111111111111111",
        "11111111111111111111111111111111111111111111111111111111111111111111111111111111"
    ];

    let levelData = [];
    let enemies = [];
    let player = new Player();

    function initLevel() {
        levelData = levelMap.map(row => row.split('').map(char => {
            if (char === '1') return 1;
            if (char === '2') return 2;
            if (char === '3') return 3;
            return 0;
        }));

        enemies = [
            new Enemy(600, 400),
            new Enemy(1200, 400),
            new Enemy(1800, 400)
        ];
    }

    function checkCollisions() {
        const p = player;
        
        // 腳下碰撞檢測點
        const footY = Math.floor((p.y + p.height) / TILE_SIZE);
        const headY = Math.floor(p.y / TILE_SIZE);
        const leftX = Math.floor(p.x / TILE_SIZE);
        const rightX = Math.floor((p.x + p.width) / TILE_SIZE);

        p.onGround = false;

        // 地形碰撞
        for (let row = 0; row < levelData.length; row++) {
            for (let col = 0; col < levelData[row].length; col++) {
                const cell = levelData[row][col];
                if (cell === 0) continue;

                const tx = col * TILE_SIZE;
                const ty = row * TILE_SIZE;

                // 碰撞判定 AABB
                if (p.x < tx + TILE_SIZE && p.x + p.width > tx && 
                    p.y < ty + TILE_SIZE && p.y + p.height > ty) {
                    
                    if (cell === 1 || cell === 3) {
                        // 處理撞到方塊
                        const overlapX = Math.min(p.x + p.width - tx, tx + TILE_SIZE - p.x);
                        const overlapY = Math.min(p.y + p.height - ty, ty + TILE_SIZE - p.y);

                        if (overlapX < overlapY) {
                            if (p.x < tx) p.x = tx - p.width;
                            else p.x = tx + TILE_SIZE;
                            p.vx = 0;
                        } else {
                            if (p.y < ty) {
                                p.y = ty - p.height;
                                p.vy = 0;
                                p.onGround = true;
                            } else {
                                p.y = ty + TILE_SIZE;
                                p.vy = 0;
                                // 如果是問號箱，可以觸發機制
                                if (cell === 3) {
                                    levelData[row][col] = 1; // 變回普通磚塊
                                    coins++;
                                    score += 100;
                                    updateUI();
                                }
                            }
                        }
                    } else if (cell === 2) {
                        // 吃到金幣
                        levelData[row][col] = 0;
                        coins++;
                        score += 200;
                        updateUI();
                    }
                }
            }
        }

        // 敵人碰撞
        enemies.forEach(e => {
            if (!e.alive) return;
            if (p.x < e.x + e.width && p.x + p.width > e.x && 
                p.y < e.y + e.height && p.y + p.height > e.y) {
                
                // 如果從上方踩
                if (p.vy > 0 && p.y + p.height < e.y + 20) {
                    e.alive = false;
                    p.vy = -10;
                    score += 500;
                    updateUI();
                } else {
                    gameOver();
                }
            }
        });
    }

    function updateUI() {
        scoreEl.innerText = score.toString().padStart(6, '0');
        coinsEl.innerText = coins;
    }

    function gameOver() {
        gameActive = false;
        alert('遊戲結束！得分: ' + score);
        startScreen.style.display = 'flex';
        player.reset();
        scrollX = 0;
        score = 0;
        coins = 0;
        updateUI();
        initLevel();
    }

    function startGame() {
        startScreen.style.display = 'none';
        initLevel();
        gameActive = true;
        requestAnimationFrame(gameLoop);
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 背景裝飾 (簡單的雲)
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(200 - (scrollX * 0.2 % 800), 100, 30, 0, Math.PI * 2);
        ctx.arc(230 - (scrollX * 0.2 % 800), 100, 40, 0, Math.PI * 2);
        ctx.arc(260 - (scrollX * 0.2 % 800), 100, 30, 0, Math.PI * 2);
        ctx.fill();

        // 繪製地圖
        for (let row = 0; row < levelData.length; row++) {
            for (let col = 0; col < levelData[row].length; col++) {
                const cell = levelData[row][col];
                const x = col * TILE_SIZE - scrollX;
                const y = row * TILE_SIZE;

                if (x < -TILE_SIZE || x > canvas.width) continue;

                if (cell === 1) {
                    ctx.fillStyle = '#8B4513'; // 土色地板
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    ctx.strokeStyle = '#5D2E0A';
                    ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                } else if (cell === 2) {
                    ctx.fillStyle = '#FFD700'; // 金幣
                    ctx.beginPath();
                    ctx.arc(x + 20, y + 20, 10, 0, Math.PI * 2);
                    ctx.fill();
                } else if (cell === 3) {
                    ctx.fillStyle = '#FFA500'; // 問號箱
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    ctx.fillStyle = 'white';
                    ctx.font = '20px Arial';
                    ctx.fillText('?', x + 15, y + 28);
                }
            }
        }

        // 繪製敵人
        enemies.forEach(e => e.draw());

        // 繪製玩家
        player.draw();
    }

    function gameLoop() {
        if (!gameActive) return;

        player.update();
        enemies.forEach(e => e.update());
        checkCollisions();

        // 攝影機追隨
        if (player.x > canvas.width / 2) {
            scrollX = player.x - canvas.width / 2;
        }

        draw();
        requestAnimationFrame(gameLoop);
    }

    // 初始化 UI
    updateUI();
</script>

</body>
</html>
