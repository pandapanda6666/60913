<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>卡皮巴拉賽車 - Z軸旋轉修正版</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #000; }
        canvas { display: block; }
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .control-btn {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(5px);
            border-radius: 15px;
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
            touch-action: none;
        }
        .control-btn:active { background: rgba(255, 255, 255, 0.4); }
        #speedometer { font-size: 32px; font-weight: bold; }
        #footer {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.9);
            font-size: 14px;
            pointer-events: auto;
            background: rgba(0,0,0,0.5);
            padding: 8px 20px;
            border-radius: 30px;
            z-index: 1000;
            text-align: center;
            white-space: nowrap;
        }
        #footer a { color: #00e5ff; text-decoration: none; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="flex justify-between items-start">
            <div id="status">
                <div id="speedometer">時速: 0 km/h</div>
                <div class="text-xl">Z 軸已旋轉 -90 度！</div>
            </div>
        </div>

        <div class="flex justify-between items-end md:hidden">
            <div class="grid grid-cols-3 gap-2">
                <div></div>
                <div id="btn-up" class="control-btn">↑</div>
                <div></div>
                <div id="btn-left" class="control-btn">←</div>
                <div id="btn-down" class="control-btn">↓</div>
                <div id="btn-right" class="control-btn">→</div>
            </div>
        </div>
    </div>

    <div id="footer">
        版權所有 © 2025 PandaPanda的AI日常 All Rights Reserved. 點擊 <a href="https://60913panda.github.io/PPAW/" target="_blank">PandaPanda的AI日常</a>
    </div>

    <script>
        let scene, camera, renderer, clock;
        let player, playerWheels = [];
        let aiCars = [];
        let speed = 0;
        let rotation = 0;
        const maxSpeed = 0.8;
        const acceleration = 0.02;
        const friction = 0.98;
        const turnSpeed = 0.04;

        const keys = { w: false, a: false, s: false, d: false, up: false, left: false, right: false, down: false };

        window.onload = function() {
            init();
            animate();
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 30, 160);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 0.9);
            sunLight.position.set(50, 100, 50);
            sunLight.castShadow = true;
            sunLight.shadow.camera.left = -70;
            sunLight.shadow.camera.right = 70;
            sunLight.shadow.camera.top = 70;
            sunLight.shadow.camera.bottom = -70;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            scene.add(sunLight);

            const groundGeo = new THREE.PlaneGeometry(2000, 2000);
            const groundMat = new THREE.MeshPhongMaterial({ color: 0x7cfc00 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            createTrack();

            // 創建玩家
            player = new THREE.Group();
            const playerModel = createCapybaraModel(0x8B4513, playerWheels);
            player.add(playerModel);
            scene.add(player);
            player.position.set(40, 0, 0); 

            // 創建 AI
            const aiConfigs = [
                { color: 0xd2a679, radius: 35, speed: 0.006, offset: 0 },
                { color: 0x5c4033, radius: 45, speed: 0.007, offset: Math.PI * 0.7 },
                { color: 0xcc9966, radius: 50, speed: 0.005, offset: Math.PI * 1.3 }
            ];

            aiConfigs.forEach(config => {
                const aiGroup = new THREE.Group();
                const aiWheels = [];
                const aiModel = createCapybaraModel(config.color, aiWheels);
                aiGroup.add(aiModel);
                scene.add(aiGroup);
                aiCars.push({
                    group: aiGroup,
                    wheels: aiWheels,
                    angle: config.offset,
                    baseRadius: config.radius,
                    baseSpeed: config.speed
                });
            });

            createEnvironment();

            window.addEventListener('keydown', e => handleKey(e.key, true));
            window.addEventListener('keyup', e => handleKey(e.key, false));
            window.addEventListener('resize', onWindowResize);
            setupTouchEvents();
        }

        function createCapybaraModel(color, wheelList) {
            const container = new THREE.Group();
            
            // 根據指令：軸 Z 改變 -90 度
            container.rotation.z = -Math.PI / 2;
            // 補償旋轉後的位移，讓模型看起來依然在地面上
            container.position.y = 0.5;

            const bodyGeo = new THREE.BoxGeometry(1, 0.8, 2);
            const bodyMat = new THREE.MeshPhongMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.6;
            body.castShadow = true;
            container.add(body);

            const headGeo = new THREE.BoxGeometry(0.8, 0.7, 0.8);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.set(0, 1, 0.8);
            head.castShadow = true;
            container.add(head);

            const noseGeo = new THREE.BoxGeometry(0.5, 0.4, 0.3);
            const noseMat = new THREE.MeshPhongMaterial({ color: 0x3d2b1f });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.set(0, 0.9, 1.2);
            container.add(nose);

            const eyeGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const eyeMat = new THREE.MeshPhongMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(0.35, 1.1, 1.05);
            container.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(-0.35, 1.1, 1.05);
            container.add(eyeR);

            const wheelGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const wheelMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
            const positions = [
                [0.5, 0.2, 0.7], [-0.5, 0.2, 0.7],
                [0.5, 0.2, -0.7], [-0.5, 0.2, -0.7]
            ];
            positions.forEach(pos => {
                const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                wheel.position.set(...pos);
                container.add(wheel);
                if (wheelList) wheelList.push(wheel);
            });

            return container;
        }

        function createTrack() {
            const trackPoints = [];
            const radius = 55;
            for(let i = 0; i <= 100; i++) {
                const a = (i / 100) * Math.PI * 2;
                trackPoints.push(new THREE.Vector2(Math.cos(a) * radius, Math.sin(a) * radius));
            }

            const trackShape = new THREE.Shape(trackPoints);
            const innerPoints = [];
            const innerRadius = 30;
            for(let i = 0; i <= 100; i++) {
                const a = (i / 100) * Math.PI * 2;
                innerPoints.push(new THREE.Vector2(Math.cos(a) * innerRadius, Math.sin(a) * innerRadius));
            }
            trackShape.holes.push(new THREE.Path(innerPoints));

            const trackGeo = new THREE.ExtrudeGeometry(trackShape, { depth: 0.15, bevelEnabled: false });
            const trackMat = new THREE.MeshPhongMaterial({ color: 0x444444 });
            const track = new THREE.Mesh(trackGeo, trackMat);
            track.rotation.x = -Math.PI / 2;
            track.position.y = 0.01;
            track.receiveShadow = true;
            scene.add(track);

            const startLine = new THREE.Mesh(
                new THREE.BoxGeometry(25, 0.1, 2),
                new THREE.MeshPhongMaterial({ color: 0xffffff })
            );
            startLine.position.set(42.5, 0.08, 0);
            scene.add(startLine);
        }

        function createEnvironment() {
            for(let i = 0; i < 100; i++) {
                const x = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;
                const dist = Math.sqrt(x*x + z*z);
                if(dist > 25 && dist < 65) continue;

                const tree = new THREE.Group();
                const trunk = new THREE.Mesh(new THREE.BoxGeometry(0.7, 3, 0.7), new THREE.MeshPhongMaterial({color: 0x5d3a1a}));
                trunk.position.y = 1.5;
                tree.add(trunk);

                const leaves = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), new THREE.MeshPhongMaterial({color: 0x2e7d32}));
                leaves.position.y = 4;
                tree.add(leaves);

                tree.position.set(x, 0, z);
                scene.add(tree);
            }
        }

        function handleKey(key, isDown) {
            const k = key.toLowerCase();
            if (k === 'w' || key === 'ArrowUp') keys.up = isDown;
            if (k === 's' || key === 'ArrowDown') keys.down = isDown;
            if (k === 'a' || key === 'ArrowLeft') keys.left = isDown;
            if (k === 'd' || key === 'ArrowRight') keys.right = isDown;
        }

        function setupTouchEvents() {
            const btns = { 'btn-up': 'up', 'btn-down': 'down', 'btn-left': 'left', 'btn-right': 'right' };
            Object.keys(btns).forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[btns[id]] = true; });
                el.addEventListener('touchend', (e) => { e.preventDefault(); keys[btns[id]] = false; });
            });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePhysics() {
            if (keys.up) speed += acceleration;
            else if (keys.down) speed -= acceleration;
            else speed *= friction;

            speed = Math.max(-maxSpeed/2, Math.min(maxSpeed, speed));

            if (Math.abs(speed) > 0.01) {
                const turnDir = speed > 0 ? 1 : -1;
                if (keys.left) rotation += turnSpeed * turnDir;
                if (keys.right) rotation -= turnSpeed * turnDir;
            }

            player.position.x += Math.sin(rotation) * speed;
            player.position.z += Math.cos(rotation) * speed;
            player.rotation.y = rotation;

            playerWheels.forEach((w, i) => {
                w.rotation.x += speed * 2;
                if(i < 2) {
                    const targetSteer = keys.left ? 0.4 : (keys.right ? -0.4 : 0);
                    w.rotation.y = THREE.MathUtils.lerp(w.rotation.y, targetSteer, 0.1);
                }
            });

            document.getElementById('speedometer').innerText = `時速: ${Math.abs(Math.round(speed * 100))} km/h`;
        }

        function updateAI() {
            aiCars.forEach(ai => {
                ai.angle += ai.baseSpeed;
                const posX = Math.cos(ai.angle) * ai.baseRadius;
                const posZ = Math.sin(ai.angle) * ai.baseRadius;
                ai.group.position.set(posX, 0, posZ);
                ai.group.rotation.y = -ai.angle + Math.PI / 2;

                ai.wheels.forEach(w => {
                    w.rotation.x += ai.baseSpeed * 20;
                });
            });
        }

        function updateCamera() {
            const offset = new THREE.Vector3(
                -Math.sin(rotation) * 12,
                6,
                -Math.cos(rotation) * 12
            );
            const targetPos = player.position.clone().add(offset);
            camera.position.lerp(targetPos, 0.1);
            camera.lookAt(player.position.x, player.position.y + 1, player.position.z);
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            updateAI();
            updateCamera();
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
